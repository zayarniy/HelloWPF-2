using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace Events
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        int count = 0;

        public MainWindow()
        {
            InitializeComponent();
            /*
                Интересно, что существует способ получать события, которые отмечены как обработанные. Вместо прикрепления обработчика события посредством XAML следует использовать рассмотренный ранее метод AddHandler(). Этот метод имеет перегруженный вариант, который принимает логическое значение в третьем параметре. Если задать его равным true, вы получите событие, даже если для него был установлен флаг Handled:              
             */
            //lblLabel.AddHandler(UIElement.MouseUpEvent, new MouseButtonEventHandler(SomeClicked), true);
            /*
            Такое решение редко бывает удачным. Кнопка предназначена для блокирования события MouseUp по очень простой причине: чтобы избежать путаницы. Ведь в Windows принято, что "щелкнуть" на кнопке можно и с помощью клавиатуры, да еще несколькими способами. Если вы ошибочно будете обрабатывать в элементе Button событие MouseUp, а не события Click, то ваш код будет реагировать только на щелчки мышью, но не на эквивалентные клавиатурные действия.
                        */
        }

        private void SomeClicked(object sender, MouseButtonEventArgs e)
        {
            count++;
            string message = "--> " + count + ":\r\n" +
                "Объект: " + sender.ToString() + "\r\n" +
                "Источник: " + e.Source.ToString() + "\r\n" +
                "Начальный источник: " + e.OriginalSource+ "\r\n";
            tbInfo.Text+=message;
            e.Handled = (bool)chb_ShowFirstEvent.IsChecked;
            /*
При установлении значения Handled свойства true в данных события для маршрутизаторного события это называется "маркировка обрабатываемого события". Нет абсолютного правила, кто должен помечать перенаправленные события как обработанные — разработчик приложения или разработчик элемента управления, который реагирует на существующие или реализует новые перенаправленные события. По большей части, понятие "обработано" в случае, если они выполняются в данных события маршрутного события, должно использоваться WPF в качестве ограниченного протокола для ответов вашего собственного приложения на различные маршрутистые события, разоблоченные в AI, а также для любых пользовательских маршрутных событий. С другой стороны, главным образом следует помечать перенаправленное событие как обработанное, если код отвечал на перенаправленное событие значительным и относительно законченным образом. Как правило, не должно быть более одного значительного ответа, которому требуется реализация отдельных обработчиков для каждого отдельного перенаправленного события. Если требуются дополнительные ответы, необходимый код должен быть реализован посредством логики приложения, связанной с простым обработчиком, а не с помощью системы перенаправленных событий для переадресации. Понятие того, что является «значительным», также субъективно и зависит от приложения или кода. В качестве общих рекомендаций можно привести следующие примеры «значительного ответа»: установка фокуса, изменение общедоступного состояния, установка свойств, влияющих на визуальное представление, и создание других новых событий. Примеры незначительных ответов: изменение закрытого состояния (без визуального воздействия или программного представления), ведение журнала событий, просмотр аргументов события и выбор не отвечать на него.     
источник:
https://docs.microsoft.com/ru-ru/dotnet/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling            
            */
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            tbInfo.Text = "";
            count = 0;
        }
    }
}
